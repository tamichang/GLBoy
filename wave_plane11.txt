
WavePlane wp[] = new WavePlane[2];

void setup() {
  size(1000, 780, P3D);
  colorMode(HSB, 360, 100, 100, 100);
  background(0,0,0);
  //stroke(330,13,99);
  noStroke();
  //fill(150,13,99);
  noFill();
  sphereDetail(10);
  
  for(int i=0; i<wp.length; i++) {
    wp[i] = new WavePlane(400,400);
  }
}

void draw() {
  background(212,84,26);
  
  translate(width/2, height*0.5, 0);
  rotateY(map(mouseX-width/2,-width/2,width/2,-PI,PI));
  rotateX(map(mouseY-width/2,-width/2,width/2,-PI,PI));
  
  for(int i=0; i<wp.length; i++) {
    wp[i].tick();
  }
  wp[0].draw();
  rotateX(PI/2);
  rotateY(PI/2);
  translate(wp[1].w/2,wp[1].h/2,0);
  wp[1].draw();
  
  
  if(rec) saveFrame("rec/" + System.currentTimeMillis());
}

class WavePlane {
  int w, h;
  
  int line_count  = 50;
  int point_count = 50;
  
  float[][][] line = new float[line_count][point_count][3];
  
  float dx, dz;
  int wave_width = 100;
  
  float[][] acnes = new float[1][2]; 
  
  float myu = 0;
  float max_sigma2 = 0.2;
  
  float max_distance = sqrt(pow(abs(0-point_count/2),2) + pow(abs(0-line_count/2),2));
  
  //int triangle_count = (point_count-1)*2 * (line_count-1);
  PVector[][][] splash_dir = new PVector[line_count][point_count][2];
  PVector[][][] splash_angle = new PVector[line_count][point_count][2];
  
  WavePlane(int w, int h) {
    this.w = w; this.h = h;
    dx = w/point_count;
    dz = h/line_count;
        
    for(int j=0; j<line_count; j++) {
      for(int i=0; i<point_count; i++) {
        splash_dir[j][i][0] = PVector.random3D();
        splash_dir[j][i][1] = PVector.random3D();
        splash_angle[j][i][0] = new PVector(random(TWO_PI),random(TWO_PI),random(TWO_PI));
        splash_angle[j][i][1] = new PVector(random(TWO_PI),random(TWO_PI),random(TWO_PI));
      }
    }
  }
  
  void tick() {
    myu = map(frameCount%180,0,180,7,-7);
    float da = TWO_PI/acnes.length;
    for(int a=0; a<acnes.length; a++) {
      //float[] acne = {cos(frameCount*0.03+da*a)*(point_count/4)*sin(frameCount*0.01)+point_count/2,
      //                sin(frameCount*0.03+da*a)*(line_count/4)*sin(frameCount*0.01)+line_count/2};
      float[] acne = {point_count/2, line_count/2};
      acnes[a] = acne;
      //println(acne[1]);
    }
    
    for(int j=0; j<line_count; j++) {
      float sigma2 = max_sigma2;
      for(int i=0; i<point_count; i++) {
        float x = i*dx;
        float y = 0;
        //y = sin(PI/point_count*i)*100;
        for(int a=0; a<acnes.length; a++) {
          float distance = sqrt(pow(abs(i-acnes[a][0]),2) + pow(abs(j-acnes[a][1]),2));
          y += -1 * 1/sqrt(TWO_PI*sigma2) * exp(-1*pow(map(distance,max_distance,0,-5,0)-myu,2)/(2*sigma2)) * wave_width;
        }
        float[] point = {x, y, j*dz};
        line[j][i] = point;
      }
    }
  }
  
  void draw_point() {
    for(int j=0; j<line_count; j++) {
      for(int i=0; i<point_count; i++) {
        float[] p = line[j][i];
        point(p[0], p[1], p[2]);
      }
    }
  }
  
  void draw() {
    
    int p_center = (int)point_count/2;
    int l_center = (int)line_count/2;
    float[] center = line[p_center][l_center];
    PVector vc = new PVector(center[0],center[1],center[2]);
    
    pushMatrix();
    translate(-w/2, 0, -h/2);
    for(int l=0; l<line_count-1; l++) {
      for(int p=0; p<point_count-1; p++) {
        float[] p1, p2, p3, p4;
        p1 = line[l][p];
        p2 = line[l][p+1];
        p3 = line[l+1][p];
        p4 = line[l+1][p+1];
        
        PVector v1 = new PVector((p1[0]+p2[0]+p3[0])/3,(p1[1]+p2[1]+p3[1])/3,(p1[2]+p2[2]+p3[2])/3);
        PVector v2 = new PVector((p2[0]+p4[0]+p3[0])/3,(p2[1]+p4[1]+p3[1])/3,(p2[2]+p4[2]+p3[2])/3);
        v1.sub(vc);
        v1.mult((sin(frameCount*0.05)+1)/2*3);
        v2.sub(vc);
        v2.mult((sin(frameCount*0.05)+1)/2*3);
        
//        PVector c1 = new PVector((p1[0]+p2[0]+p3[0])/3,(p1[1]+p2[1]+p3[1])/3,(p1[2]+p2[2]+p3[2])/3);
//        PVector c2 = new PVector((p2[0]+p4[0]+p3[0])/3,(p2[1]+p4[1]+p3[1])/3,(p2[2]+p4[2]+p3[2])/3);
//        
//        PVector v1 = splash_dir[l][p][0];
//        v1 = PVector.mult(v1,(sin(frameCount*0.03)+1)/2*600);
//        PVector v2 = splash_dir[l][p][1];
//        v2 = PVector.mult(v2,(sin(frameCount*0.03)+1)/2*600);
//        
//        fill(360/point_count*p,10,95);
//        
//        pushMatrix();
//          translate(c1.x,c1.y,c1.z);
//          pushMatrix();
//            rotateX((sin(frameCount*0.03)+1)/2*splash_angle[l][p][0].x);
//            rotateY((sin(frameCount*0.03)+1)/2*splash_angle[l][p][0].y);
//            rotateZ((sin(frameCount*0.03)+1)/2*splash_angle[l][p][0].z);
//            beginShape(TRIANGLES);
//            vertex(p1[0]-c1.x+v1.x, p1[1]-c1.y+v1.y, p1[2]-c1.z+v1.z);
//            vertex(p2[0]-c1.x+v1.x, p2[1]-c1.y+v1.y, p2[2]-c1.z+v1.z);
//            vertex(p3[0]-c1.x+v1.x, p3[1]-c1.y+v1.y, p3[2]-c1.z+v1.z);
//            endShape();
//          popMatrix();
//        popMatrix();
//        
//        pushMatrix();
//          translate(c2.x,c2.y,c2.z);
//          pushMatrix();
//            rotateX((sin(frameCount*0.03)+1)/2*splash_angle[l][p][1].x);
//            rotateY((sin(frameCount*0.03)+1)/2*splash_angle[l][p][1].y);
//            rotateZ((sin(frameCount*0.03)+1)/2*splash_angle[l][p][1].z);
//            beginShape(TRIANGLES);
//            vertex(p2[0]-c2.x+v2.x, p2[1]-c2.y+v2.y, p2[2]-c2.z+v2.z);
//            vertex(p3[0]-c2.x+v2.x, p3[1]-c2.y+v2.y, p3[2]-c2.z+v2.z);
//            vertex(p4[0]-c2.x+v2.x, p4[1]-c2.y+v2.y, p4[2]-c2.z+v2.z);
//            endShape();
//          popMatrix();
//        popMatrix();  
        
        
        /*
        pushMatrix();
        translate((p1[0]+p2[0])/2,(p1[1]+p2[1])/2,(p1[2]+p2[2])/2);
        //box(5);
        sphere(3);
        popMatrix();
        */
        
        beginShape(TRIANGLES);
        stroke(360,10,95,70/point_count*p);
        vertex(p1[0], p1[1], p1[2]);
        vertex(p2[0], p2[1], p2[2]);
        vertex(p3[0], p3[1], p3[2]);
        
        vertex(p2[0], p2[1], p2[2]);
        vertex(p3[0], p3[1], p3[2]);
        vertex(p4[0], p4[1], p4[2]);
        
        
//        //fill(250,map(p1[1],-50,50,0,100),100);
//        vertex(p1[0], p1[1]+(noise(p*0.05,l*0.05,frameCount*0.02)*2-1)*60, p1[2]);
//        //fill(250,map(p2[1],-50,50,0,100),100);
//        vertex(p2[0], p2[1]+(noise((p+1)*0.05,l*0.05,frameCount*0.02)*2-1)*60, p2[2]);
//        //fill(250,map(p3[1],-50,50,0,100),100);
//        vertex(p3[0], p3[1]+(noise(p*0.05,(l+1)*0.05,frameCount*0.02)*2-1)*60, p3[2]);
//        
//        //fill(250,map(p2[1],-50,50,0,100),100);
//        vertex(p2[0], p2[1]+(noise((p+1)*0.05,l*0.05,frameCount*0.02)*2-1)*60, p2[2]);
//        //fill(250,map(p3[1],-50,50,0,100),100);
//        vertex(p3[0], p3[1]+(noise(p*0.05,(l+1)*0.05,frameCount*0.02)*2-1)*60, p3[2]);
//        //fill(250,map(p4[1],-50,50,0,100),100);
//        vertex(p4[0], p4[1]+(noise((p+1)*0.05,(l+1)*0.05,frameCount*0.02)*2-1)*60, p4[2]);
        
//        //fill(250,map(p1[1],-50,50,0,100),100);
//        vertex(p1[0]+v1.x, p1[1]+v1.y, p1[2]+v1.z);
//        //fill(250,map(p2[1],-50,50,0,100),100);
//        vertex(p2[0]+v1.x, p2[1]+v1.y, p2[2]+v1.z);
//        //fill(250,map(p3[1],-50,50,0,100),100);
//        vertex(p3[0]+v1.x, p3[1]+v1.y, p3[2]+v1.z);
//        
//        //fill(250,map(p2[1],-50,50,0,100),100);
//        vertex(p2[0]+v2.x, p2[1]+v2.y, p2[2]+v2.z);
//        //fill(250,map(p3[1],-50,50,0,100),100);
//        vertex(p3[0]+v2.x, p3[1]+v2.y, p3[2]+v2.z);
//        //fill(250,map(p4[1],-50,50,0,100),100);
//        vertex(p4[0]+v2.x, p4[1]+v2.y, p4[2]+v2.z);
        endShape();
      }
    }
    popMatrix();
  }
  
}

boolean rec = false;

void keyPressed() {
  if (key == 'r') { 
    rec = rec ^ true;
  }
  if (keyCode == ENTER) {
    saveFrame("image/screen-" + System.currentTimeMillis() + ".png");
  }
}

void mouseWheel(MouseEvent event) {
  float e = event.getCount();
  println(e);
}