
WavePlane wp = new WavePlane(400,400);

void setup() {
  size(1000, 780, P3D);
  colorMode(HSB, 360, 100, 100, 100);
  background(0,0,0);
  //stroke(330,13,99);
  noStroke();
  //fill(150,13,99);
  noFill();
  sphereDetail(10);
}

void draw() {
  background(212,84,26);
  
  translate(width/2, height*0.5, 0);
  rotateY(map(mouseX-width/2,-width/2,width/2,-PI,PI));
  rotateX(map(mouseY-width/2,-width/2,width/2,-PI,PI));
  
  wp.tick();
  wp.draw();
  
  if(rec) saveFrame("rec/" + System.currentTimeMillis());
}

class WavePlane {
  int w, h;
  
  int line_count  = 100;
  int point_count = 100;
  
  float[][][] line = new float[line_count][point_count][3];
  
  float dx, dz;
  int wave_width = 100;
  float da = 0.1;
  float dla = 0.5;
  
  float[][] acnes = new float[0][2]; 
  
  float myu = 0;
  float max_sigma2 = 0.5;
  
  float max_distance = sqrt(pow(abs(0-point_count/2),2) + pow(abs(0-line_count/2),2));
  
  //int triangle_count = (point_count-1)*2 * (line_count-1);
  PVector[][][] splash_dir = new PVector[line_count][point_count][2];
  PVector[][][] splash_angle = new PVector[line_count][point_count][2];
  
  WavePlane(int w, int h) {
    this.w = w; this.h = h;
    dx = w/point_count;
    dz = h/line_count;
        
    for(int j=0; j<line_count; j++) {
      for(int i=0; i<point_count; i++) {
        splash_dir[j][i][0] = PVector.random3D();
        splash_dir[j][i][1] = PVector.random3D();
        splash_angle[j][i][0] = new PVector(random(TWO_PI),random(TWO_PI),random(TWO_PI));
        splash_angle[j][i][1] = new PVector(random(TWO_PI),random(TWO_PI),random(TWO_PI));
      }
    }
  }
  
  void tick() {
    //myu = map(frameCount%180,0,180,7,-7);
    float da = TWO_PI/acnes.length;
    for(int a=0; a<acnes.length; a++) {
      float[] acne = {cos(frameCount*0.03+da*a)*(point_count/4)*sin(frameCount*0.01)+point_count/2,
                      sin(frameCount*0.03+da*a)*(line_count/4)*sin(frameCount*0.01)+line_count/2};
      //float[] acne = {point_count/2, line_count/2};
      acnes[a] = acne;
      //println(acne[1]);
    }
    
    /*int pcenter = (int) point_count/2;
    int pbound1 = (int) point_count/4;
    int pbound2 = pcenter+(pcenter-pbound1);
    float dx = w/2/pbound1;
    float dax = TWO_PI/(pcenter-pbound1);*/
    
    for(int j=0; j<line_count; j++) {
      //float sigma2 = map(abs(line_count/2-j),0,line_count/2,max_sigma2,5);
      float sigma2 = max_sigma2;
      for(int i=0; i<point_count; i++) {
        /*float x;
        if(i<pbound1) {
          x = dx*i;
        } else if(i<pcenter) {
          x = w/4*3+sin(dax*i+PI/2)*w/4;
        } else if(i<pbound2) {
          x = w/4*3+sin(dax*i+PI/2*3)*w/4;;
        } else {
          x = w/2+dx*i;
        }*/
        float x = i*dx;
        //float x = i<point_count/2? i*dx : dx*(int)point_count/2 - (i*dx - dx*(int)point_count/2);
        float y = 0;
        //y = sin(PI/point_count*i)*100;
        for(int a=0; a<acnes.length; a++) {
          //float y = sin(i*da+dla*j+frameCount*0.1) * wave_width/2;
          float distance = sqrt(pow(abs(i-acnes[a][0]),2) + pow(abs(j-acnes[a][1]),2));
          //float y = -1 * 1/sqrt(TWO_PI*sigma2) * exp(-1*pow(map(i,0,point_count-1,-5,5)-myu,2)/(2*sigma2)) * wave_width;
          y += -1 * 1/sqrt(TWO_PI*sigma2) * exp(-1*pow(map(distance,max_distance,0,-5,0)-myu,2)/(2*sigma2)) * wave_width;
          //y = y * map(abs(line_count/2-j),0,line_count/2,2,0);
          //if(frameCount == 10 && j==0) println(map(distance,50,0,-5,0));
        }
        float[] point = {x, y, j*dz};
        line[j][i] = point;
      }
    }
  }
  
  void draw_point() {
    for(int j=0; j<line_count; j++) {
      for(int i=0; i<point_count; i++) {
        float[] p = line[j][i];
        point(p[0], p[1], p[2]);
      }
    }
  }
  
  void draw() {
    
    int p_center = (int)point_count/2;
    int l_center = (int)line_count/2;
    float[] center = line[p_center][l_center];
    PVector vc = new PVector(center[0],center[1],center[2]);
    //float[] down_center = line[p_center][0];
    //PVector downv = new PVector(down_center[0],down_center[1],down_center[2]);
    //downv.sub(vc);
    
    pushMatrix();
    translate(-w/2, 0, -h/2);
    for(int l=0; l<line_count-1; l++) {
      for(int p=0; p<point_count-1; p++) {
        float[] p1, p2, p3, p4;
        p1 = line[l][p];
        p2 = line[l][p+1];
        p3 = line[l+1][p];
        p4 = line[l+1][p+1];
        
//        PVector v1 = new PVector((p1[0]+p2[0]+p3[0])/3,(p1[1]+p2[1]+p3[1])/3,(p1[2]+p2[2]+p3[2])/3);
//        PVector v2 = new PVector((p2[0]+p4[0]+p3[0])/3,(p2[1]+p4[1]+p3[1])/3,(p2[2]+p4[2]+p3[2])/3);
//        v1.sub(vc);
//        v1.mult((sin(frameCount*0.05)+1)/2*3);
//        v2.sub(vc);
//        v2.mult((sin(frameCount*0.05)+1)/2*3);
        
        PVector c1 = new PVector((p1[0]+p2[0]+p3[0])/3,(p1[1]+p2[1]+p3[1])/3,(p1[2]+p2[2]+p3[2])/3);
        PVector c2 = new PVector((p2[0]+p4[0]+p3[0])/3,(p2[1]+p4[1]+p3[1])/3,(p2[2]+p4[2]+p3[2])/3);
        
        PVector v1 = splash_dir[l][p][0];
        v1 = PVector.mult(v1,(sin(frameCount*0.03)+1)/2*600);
        PVector v2 = splash_dir[l][p][1];
        v2 = PVector.mult(v2,(sin(frameCount*0.03)+1)/2*600);
        
        fill(360/point_count*p,10,95);
        
        pushMatrix();
          translate(c1.x,c1.y,c1.z);
          pushMatrix();
            rotateX((sin(frameCount*0.03)+1)/2*splash_angle[l][p][0].x);
            rotateY((sin(frameCount*0.03)+1)/2*splash_angle[l][p][0].y);
            rotateZ((sin(frameCount*0.03)+1)/2*splash_angle[l][p][0].z);
            beginShape(TRIANGLES);
            vertex(p1[0]-c1.x+v1.x, p1[1]-c1.y+v1.y, p1[2]-c1.z+v1.z);
            vertex(p2[0]-c1.x+v1.x, p2[1]-c1.y+v1.y, p2[2]-c1.z+v1.z);
            vertex(p3[0]-c1.x+v1.x, p3[1]-c1.y+v1.y, p3[2]-c1.z+v1.z);
            endShape();
          popMatrix();
        popMatrix();
        
        pushMatrix();
          translate(c2.x,c2.y,c2.z);
          pushMatrix();
            rotateX((sin(frameCount*0.03)+1)/2*splash_angle[l][p][1].x);
            rotateY((sin(frameCount*0.03)+1)/2*splash_angle[l][p][1].y);
            rotateZ((sin(frameCount*0.03)+1)/2*splash_angle[l][p][1].z);
            beginShape(TRIANGLES);
            vertex(p2[0]-c2.x+v2.x, p2[1]-c2.y+v2.y, p2[2]-c2.z+v2.z);
            vertex(p3[0]-c2.x+v2.x, p3[1]-c2.y+v2.y, p3[2]-c2.z+v2.z);
            vertex(p4[0]-c2.x+v2.x, p4[1]-c2.y+v2.y, p4[2]-c2.z+v2.z);
            endShape();
          popMatrix();
        popMatrix();
        
        
        
        /*
        pushMatrix();
        translate((p1[0]+p2[0])/2,(p1[1]+p2[1])/2,(p1[2]+p2[2])/2);
        //box(5);
        sphere(3);
        popMatrix();
        */
      }
    }
    popMatrix();
  }
  
}

boolean rec = false;

void keyPressed() {
  if (key == 'r') { 
    rec = rec ^ true;
  }
  if (keyCode == ENTER) {
    saveFrame("image/screen-" + System.currentTimeMillis() + ".png");
  }
}

void mouseWheel(MouseEvent event) {
  float e = event.getCount();
  println(e);
}